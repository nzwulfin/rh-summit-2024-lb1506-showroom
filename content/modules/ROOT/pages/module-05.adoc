= Rolling back bootc systems

In this lab, you'll look at rollbacks and examine how bootc handles directories on updates.

[#rollback-vm]
== Rolling back changes to the virtual machine
You should still be logged into the bootc VM (the prompt should look like `[lab@qcow-vm ~]$`), if not log back in now.

[source,bash]
----
ssh lab-user@qcow-vm
----

Before we explore the httpd problem, we have a new option available to image mode systems that takes more 
preparation with package mode operations: the rollback. Since `bootc` manages state on disk, we have the 
previous working system available to us. Normally, we'd need to have set up snapshots or refer to a backup 
but `bootc` automatically provides us the rollback built in.

Let's check for an available rollback option to get us back to the previous image.
[source,bash]

----
sudo bootc status
----
WARNING: output needed

Looking at the status output, we can see there's a section marked `rollback`. There are at most 3 images 
available on disk at any one time: 

* the currently active image (`booted`)
* the image that will be actived next (`staged`) 
* the fallback image that we're be looking for here. 

Not all of these sections will have information at all times.

Luckily, rollbacks are as simple as running one command. Let's get this image back to the previous
state then we can dig into what happened.

[source,bash]
----
sudo bootc rollback
----

The command should return very fast and the output looks like this:

----
bootfs is sufficient for calculated new size: 0 bytes
Next boot: rollback deployment
----

As usual, a reboot is needed. Before doing it, please make sure you are logged in to the
virtual machine and not the hypervisor (the prompt should look like `[lab@qcow-vm ~]$`):

[source,bash]
----
sudo systemctl reboot
----

[#directory-layout]
== How image mode handles directories

On the lab host, we're going to make some changes to the Containerfile to account for how
directories are managed by `bootc`.

In an image mode system, `bootc` manages available images on disk for updates and rollbacks. 
You just created an update, applied it, then returned to a previous version all through `bootc`.
Behind the scenes, `bootc` handles the following directories differently, which is what allows
for the seamless update and rollback experience. 

  * `/usr` -> image state, contents of the image will be extracted and overwrite local files
  * `/etc` -> local configuration state, changes are merged with image contents with a preference for local files
  * `/var` -> local state, contents of the image will be ignored after the inital installation of any image

The configuration files we added to `/etc` showed up after the update as a result of the merge treatment of bootc.
If we'd made local changes that conflicted, we'd see the local changes rather than the new configs.

Our initial web page went in `/var` which means after it was unpacked from the original image, `bootc`
treated it as local machine state. So our update in the container wasn't applied to the running host. 
Since we want to control the contents of our webserver from the image, we'll need to make some changes 
to where we put content and how we serve it in Apache.

[source,dockerfile]
----
FROM registry.redhat.io/rhel9/rhel-bootc:9.4

COPY certs/004-summit.conf /etc/containers/registries.conf.d/004-summit.conf

ADD etc/ /etc

RUN dnf install -y httpd

RUN mv /var/www /usr/share/www && \
    sed -ie 's,/var/www,/usr/share/www,' /etc/httpd/conf/httpd.conf

RUN echo "Hello Red Hat Summit Connect 2024!!" > /usr/share/www/index.html

RUN systemctl enable httpd.service
----

Let's break down that added `RUN` directive.

The `httpd` package drops content in /var/www by default, and on bootc systems
we have /var as machine local. Since we want to control web content in the image, 
we need to move it to somewhere under `bootc` control. In our Containerfile, we move 
the default package contents to our new location in `/usr` then update the Apache 
configuration to serve pages from this new directory. We've also changed the echo line 
to create the index.html in the new location.

Rebuild the image with our new configuration and index page:

[source,bash]
----
podman build --file Containerfile --tag summit.registry/lb1506:bootc
----

And make sure to push it to the registry:

[source,bash]
----
podman push summit.registry/lb1506:bootc
----
[#update2-vm]
== Updating the virtual machine

Now you can ssh into the virtual machine

[source,bash]
----
ssh lab-user@qcow-vm
----

Previously, we checked for an update, downloaded and staged it locally to be activated, then manually rebooted 
the system to have the update take effect. This is a very good procedure for a manual update or in places 
where we need to schedule any outages ahead of time, say during a maintenance window. We can do this all at 
once by adding a flag to the `update` command. This gives us a way to automate the process, like with a systemd
timer. Image mode hosts ship with this timer by default.


[source,bash]
----
sudo systemctl status bootc-fetch-apply-updates.timer
----

Instead of waiting for this timer to trigger, we can immediately apply the new update and reboot.

[source,bash]
----
sudo bootc update --apply
----

If you catch the output before the reboot, it should look like the previous update command.

----
Loading usr/lib/ostree/prepare-root.conf
Queued for next boot: summit.registry/lb1506:bootc-auth
  Version: 9.20240501.0
  Digest: sha256:c5a5bc63cc5d081c528c82a177d0c5eac996a16fa3a651f93d07825302ff5336
Total new layers: 73    Size: 947.9 MB
Removed layers:   6     Size: 2.3 kB
Added layers:     6     Size: 2.2 kB
----

[#testing]
== Testing the changes

Shortly after reboot, check for our new web page:

[source,bash]
----
curl http://qcow-vm
----

Now the output should be "Hello Red Hat Summit Connect 2024!!"
