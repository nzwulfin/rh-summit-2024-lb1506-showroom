= Repurposing a bootc host

In addition to simplifying updates and providing native rollback, operating RHEL in image mode also 
makes it simple to quickly change the purpose of a running system. This means experimenting with new 
versions of application components or testing OS updates is as simple as applying any other image change.

In this lab we'll explore this feature as well as expand on the ideas of layering common in the application 
container world.

[#write-containerfiles]
== Writing advanced containerfiles

NOITE: All of the files for this exercise are provided in the examples folder and we'll be operating on those 
directly. If a command doesn't operate, or a file doesn't look correct, check to make sure you are in the right 
directory.

Instead of just running a webserver, what if we needed to run WordPress instances, and our developers need
those to be containerized? Image mode hosts are suitable for a wide range of use cases beyond directly hosting 
applications, and acting as a container host is one of those. In fact, the work that preceeded image mode was 
largely focused on the role of container hosting. 

On the host system (make sure the prompt shows `[lab-user@hypervisor edge-os]$`), you can
change to the wordpress-quadlet directory to examine the new Containerfile.

[source,bash]
----
cd examples/wordpress-quadlet
nano Containerfile.wp
----
Using container tooling to create images let's us take advantage of layers and inheritance in our standard 
build process. Different teams and work directly from images built by others, rather than by integrating after 
the fact. Notice our `FROM` line is the image you've been working on throughout the lab. This means that every 
bit of customization and software you've installed previously will be available on the host built from this new 
definition. 

[source,dockerfile]
----
FROM summit.registry/lb1506:bootc

RUN dnf -y install lynx

ADD etc etc
ADD usr usr
----

For an 'advanced` configuration, this doesn't have a lot of content, what's happening?

Remember the `ADD` directive pulls full directories into the image at build time. So all of the work here is 
somehow being done in `/usr` or `/etc`, let's see what's in there.

The advanced part is the use of quadlets to run containers. A full description of quadlets is outside the scope 
of this workshop, but in short, a quadlet is a way to run a container (or group of containers in this case) as a 
systemd service. In `/etc/` we have a configuration file for the caddy server, a Golang HTTPS server acting as a proxy, 
and a file of environment variables to be passed to the quadlet.

In `/usr/share/containers/systemd/` we have all of the files that define the quadlet. The `.container` file defines 
each of the containers for systemd to run. These are typical systemd unit files, aside from the `[Container]` block which 
is unique to quadlets.

[#build]
== Build and push the image

You can now build the image:

[source,bash]
----
podman build --file Containerfile.wp --tag summit.registry/lb1506:bootc-wp
----

And of course push it to the local registry:

[source,bash]
----
podman push summit.registry/lb1506:bootc-wp
----

You can now login to the virtual machine:

[source,bash]
----
ssh lab-user@qcow-vm
----

[switch-run]
== Switch and test the image

After the new container image has been pushed to the local registry,
you can `switch` the bootc image to the WordPress one.

[source,bash]
----
sudo bootc switch summit.registry/lb1506:bootc-wp
----

As usual, after the command is done you need to reboot the virtual machine
for the changes to take effect. Before doing that, please make sure you are logged in to the
virtual machine and not the hypervisor (the prompt should look like `[lab-user@qcow-vm ~]#`):

[source,bash]
----
sudo systemctl reboot
----

After a short while, you can log back in to the virtual machine:

[source,bash]
----
ssh lab-user@qcow-vm
----

[#layers]
== Troubleshooting layered builds

What was that failure we were notified about? 

[source,bash]
----
sudo systemctl status caddy.service
sudo journalctl -t caddy
----

We weren't prompted for our sudo password, but it looks like our new caddy server couldn't bind to port 80 
when it tried to start.  What's going on? The answer to both lies in the image we built from. 

If you look at the original Containerfile, you'll recall we set Apache to start at boot:

[source,dockerfile]
----
RUN systemctl enable httpd.service
----

If we check the status of Apache, we can see that it is indeed running and listening on port 80.

[source,bash]
----
sudo systemctl status httpd.service
----

Since local changes to /etc are kept by `bootc` when changing images, httpd stayed enabled on 
this new host as well. Let's disable it and restart caddy.

[source,bash]
----
sudo systemctl disable --now httpd.service
sudo systemctl restart caddy.service
sudo systemctl status caddy.service
----

It looks like caddy started, let's check to see that it's passing requests to the WordPress 
container in the quadlet. We don't have a GUI, but that's why we installed the Lynx browser

[source,bash]
----
lynx localhost
----

You should see the WordPress configuration dialog box. You can hit `Esc` and then `q` to quit lynx.

Easy updates, rollbacks, and image switching are part of the core improvements to the operation of 
image mode systems. Layering is an important part of the design of standard builds and can have some 
downstream effects as well. Just like stacking configuration management, thinking through the idea of 
layered builds can be powerful.

But those aren't the only advantages or design considerations when thinking about 
how to best use image mode in your workflows. Let's explore a few more advanced topics next.

